<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Experiment Results</title>
  <style>
    :root {
      --bg: #111827;
      --surface: #1f2937;
      --border: #374151;
      --text: #f9fafb;
      --muted: #9ca3af;
      --accent: #3b82f6;
      --success: #22c55e;
      --error: #ef4444;
    }
    body {
      margin: 0;
      font-family: system-ui, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
      padding: 2rem;
    }
    h1 { margin-top: 0; }
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem;
      margin-bottom: 1.5rem;
      overflow-x: auto;
    }
    .result {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 1rem 1.25rem;
      margin-bottom: 1.5rem;
    }
    .header {
      font-weight: 700;
      font-size: 1.1rem;
      margin-bottom: .5rem;
    }
    .badge { margin-left: .5rem; }
    .field { margin: .4rem 0; }
    .field span { font-weight: 600; color: var(--muted); }
    pre {
      background: var(--bg);
      color: var(--text);
      padding: .8rem;
      border-radius: 6px;
      overflow: auto;
      font-size: .9rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
    }
    th, td {
      padding: .5rem .8rem;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    th {
      background: var(--bg);
      font-weight: 600;
    }
    td {
      background: var(--surface);
    }
  </style>
</head>
<body>

<h1>Experiment Results</h1>

<select id="dirSelect" style="margin-bottom:1rem; padding:.4rem; font-size:1.2rem;">
  <!-- options injected by script -->
</select>

<div id="summary" class="card"></div>

<div id="container">Loading…</div>

<script>
(async () => {
  const container   = document.getElementById('container');
  const dirSelect   = document.getElementById('dirSelect');
  const summaryDiv  = document.getElementById('summary');

  const IS_LOCAL = location.hostname === 'localhost'

  // ----------------------------------------------------------------------
  // Helper: fetch raw items (files + directories) from the GitHub Contents API
  // ----------------------------------------------------------------------
  const fetchLinks = async (path) => {
    if (IS_LOCAL) {
      // Get the directory listing HTML (the simple index page that python/http-server or npx serve produce)
      const resp = await fetch(`${path}`);
      if (!resp.ok) throw new Error(`Failed to list ${path}`);
      const html = await resp.text();

      // Parse the <a> links from the generated index page
      const doc   = new DOMParser().parseFromString(html, 'text/html');
      const links = [...doc.querySelectorAll('a')]
        .map(a => a.getAttribute('href'))
        .filter(h => h && h !== '../');               // ignore the parent‑dir link

      // Convert each link into the same shape the GitHub API returns
      return links.map(h => {
        const isDir = h.endsWith('/');
        const cleanName = isDir ? h.slice(0, -1) : h;
        const fullPath = `${path}/${cleanName}`;
        return {
          name: cleanName,
          type: isDir ? 'dir' : 'file',
          path: fullPath,
          download_url: fullPath            // relative URL works for local files
        };
      });
    } else {
      const apiUrl = `https://api.github.com/repos/42automation/long-context-experiments/contents/docs/${path}`;
      const resp   = await fetch(apiUrl);
      if (!resp.ok) throw new Error(`GitHub API error ${resp.status}`);
      return await resp.json();   // [{name, path, type, download_url, …}, …]
    }
  };

  // Helper: format token counts (e.g., 1230 → 1.23K)
  const formatTokens = (count) => {
    const num = Number(count);
    if (isNaN(num)) return count;
    const k = num / 1000;
    const formatted = k.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 2});
    return `${formatted}K`;
  };

  // --------------------------------------------------------------
  // Get the list of sub‑directories that hold experiment runs.
  // --------------------------------------------------------------
  const rootItems = await fetchLinks('.');
  const subDirs = rootItems
    .filter(item => item.type === 'dir')
    .map(item => item.name);

  // Sort so newest (lexicographically highest) appears first
  subDirs.sort((a, b) => b.localeCompare(a));

  // Populate the dropdown
  subDirs.forEach((d, i) => {
    const opt = document.createElement('option');
    opt.value = d;
    opt.textContent = d || '/';
    if (i === 0) opt.selected = true;
    dirSelect.appendChild(opt);
  });

  // --------------------------------------------------------------
  // Render the summary table
  // --------------------------------------------------------------
  const renderSummary = (results) => {
    const summary = {};
    results.forEach(r => {
      const model = r.model || 'unknown';
      if (!summary[model]) summary[model] = {passed: 0, failed: 0};
      r.passed ? summary[model].passed++ : summary[model].failed++;
    });
    const rows = Object.entries(summary).map(
      ([model, {passed, failed}]) => `
        <tr>
          <td>${model}</td><td>${passed}</td><td>${failed}</td>
        </tr>`).join('');
    summaryDiv.innerHTML = `
      <h2>Summary</h2>
      <table>
        <thead>
          <tr><th>Model name</th><th>Passed ✅</th><th>Failed ❌</th></tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>`;
  };

  // --------------------------------------------------------------
  // Load and display results from a given subdirectory
  // --------------------------------------------------------------
  const loadResults = async (dir) => {
    container.innerHTML = '<p>Loading…</p>';
    summaryDiv.innerHTML = '';

    // Fetch all items inside the chosen subdirectory
    const dirItems = await fetchLinks(`${dir}`);

    // Keep only JSON files and use their raw download URL
    const jsonLinks = dirItems
      .filter(i => i.type === 'file' && i.name.toLowerCase().endsWith('.json'))
      .map(i => i.download_url);

    if (jsonLinks.length === 0) {
      container.innerHTML = '<p>No JSON files found.</p>';
      return;
    }

    // Load every JSON payload
    const results = await Promise.all(
      jsonLinks.map(async (url) => {
        const resp = await fetch(url);
        const data = await resp.json();
        return {...data, _filename: url};
      })
    );

    // Sort by experiment id (adjust if you prefer date sorting)
    results.sort((a, b) => a.id.localeCompare(b.id));

    // Render summary then detailed cards
    renderSummary(results);
    container.innerHTML = '';
    results.forEach(r => {
      const badge = r.passed ? '✅' : '❌';
      const el = document.createElement('div');
      el.className = 'result';
      el.innerHTML = `
        <div class="header">
          Experiment ID: ${r.id}
          <span class="badge">${badge}</span>
        </div>
        <div class="field"><span>Model:</span> ${r.model}</div>
        <div class="field"><span>Query:</span> ${r.query}</div>
        <div class="field"><span>Expected answer:</span> ${r.expected_answer}</div>
        <div class="field"><span>Input context:</span> ${formatTokens(r.input_tokens)}</div>
        <div class="field"><span>Output:</span></div>
        <pre>${r.output}</pre>
        <div class="field"><small>Source file: ${r._filename}</small></div>`;
      container.appendChild(el);
    });
  };

  // Initial load (first subdirectory, if any)
  if (subDirs.length > 0) {
    loadResults(subDirs[0]);
  } else {
    container.innerHTML = '<p>No subdirectories found.</p>';
  }

  // Reload when the user selects a different directory
  dirSelect.addEventListener('change', e => loadResults(e.target.value));
})();
</script>

</body>
</html>
